    else if (MODE == "WSPR") // TODO: Un-hardcode this
    {
        // WSPR mode
        for (;;)
        { // Reload Loop >
            // Initialize WSPR Message (message)
            WsprMessage message(CALL, GRID, PWR); // TODO:  Check if we have enough chars for callsigns

            // Access the generated symbols
            unsigned char *symbols = message.symbols;

            llog.logS(INFO, "Ready to transmit (setup complete).");

            for (;;)
            {
                // Calculate WSPR parameters for this transmission
                double center_freq_desired;
                center_freq_desired = 7040100.0;
                bool wspr15 =
                    (center_freq_desired > 137600 && center_freq_desired < 137625) ||
                    (center_freq_desired > 475800 && center_freq_desired < 475825) ||
                    (center_freq_desired > 1838200 && center_freq_desired < 1838225);
                double wspr_symtime = (wspr15) ? 8.0 * WSPR_SYMTIME : WSPR_SYMTIME;
                double tone_spacing = 1.0 / wspr_symtime;

                // Add random offset
                if ((center_freq_desired != 0) && true) // TODO: Un-hardcode this (offset)
                {
                    center_freq_desired += (2.0 * rand() / ((double)RAND_MAX + 1.0) - 1.0) * (wspr15 ? WSPR15_RAND_OFFSET : WSPR_RAND_OFFSET);
                }

                // Status message before transmission
                std::stringstream temp;
                temp << std::setprecision(6) << std::fixed;
                temp << "Center frequency for " << (wspr15 ? "WSPR-15" : "WSPR") << " trans: " << center_freq_desired / 1e6 << " MHz.";
                llog.logS(INFO, temp.str());

                // Wait for WSPR transmission window to arrive.
                if (true) // TODO: Un-hardcode this (delay)
                {
                    llog.logS(INFO, "Transmitting immediately (not waiting for WSPR window.)");
                }
                else
                {
                    int interval = wspr15 ? 15 : 2;
                    llog.logS(INFO, "Waiting for next WSPR (", interval, ") transmission window.");
                    if (!wait_every(interval))
                    {
                        // Break and reload if ini changes
                        break;
                    };
                }

                // Create the DMA table for this center frequency
                std::vector<double> dma_table_freq;
                double center_freq_actual;
                if (center_freq_desired)
                {
                    setupDMATab(center_freq_desired, tone_spacing, config.f_plld_clk * (1 - PPM_VAL / 1e6), dma_table_freq, center_freq_actual, constPage);
                }
                else
                {
                    center_freq_actual = center_freq_desired;
                }

                // Send the message if freq != 0 and transmission is enabled
                if (center_freq_actual && true) // TODO: Un-hardcode this
                {
                    // Print a status message right before transmission begins.
                    llog.logS(INFO, "Transmission started.");

                    struct timeval tvBegin, sym_start, diff;
                    gettimeofday(&tvBegin, NULL);
                    int bufPtr = 0;

                    // Get Begin Timestamp
                    auto txBegin = std::chrono::high_resolution_clock::now();

                    txon();
                    for (int i = 0; i < 162; i++)
                    {
                        gettimeofday(&sym_start, NULL);
                        timeval_subtract(&diff, &sym_start, &tvBegin);
                        double elapsed = diff.tv_sec + diff.tv_usec / 1e6;
                        double sched_end = (i + 1) * wspr_symtime;
                        double this_sym = sched_end - elapsed;
                        this_sym = (this_sym < .2) ? .2 : this_sym;
                        this_sym = (this_sym > 2 * wspr_symtime) ? 2 * wspr_symtime : this_sym;
                        txSym(symbols[i], center_freq_actual, tone_spacing, sched_end - elapsed, dma_table_freq, F_PWM_CLK_INIT, instrs, constPage, bufPtr);
                    }

                    // Turn transmitter off
                    txoff();

                    // Get End Timestamp
                    auto txEnd = std::chrono::high_resolution_clock::now();
                    // Calculate duration in <double> seconds
                    std::chrono::duration<double, std::milli> elapsed = (txEnd - txBegin) / 1000;
                    double num_seconds = elapsed.count();
                    llog.logS(INFO, "Transmission complete (", num_seconds, " sec.)");
                }
                else
                {
                    llog.logS(INFO, "Skipping transmission.");
                    usleep(1000000);
                }

                // TODO: Advance to next band
                // TODO: Check repeat
            }
        } // < Reload Loop
    }
