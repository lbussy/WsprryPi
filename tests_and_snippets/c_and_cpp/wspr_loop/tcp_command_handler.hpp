/**
 * @file tcp_command_handler.hpp
 * @brief Implements command parsing and response for TCP_Server commands.
 *
 * @details
 * This is an application-specific override of the functional example in the
 * TCP-Server library. It maps incoming string commands to appropriate handler
 * functions using lambdas and std::function, allowing the server to interpret
 * and respond to client instructions.
 *
 * @see https://github.com/lbussy/TCP-Server
 *
 * This file is part of WsprryPi, a project originally created from @threeme3
 * WsprryPi projet (no longer on GitHub). However, now the original code
 * remains only as a memory and inspiration, and this project is no longer
 * a deriivative work.
 *
 * This project is is licensed under the MIT License. See LICENSE.MIT.md
 * for more information.
 *
 * Copyright (C) 2023-2025 Lee C. Bussy (@LBussy). All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef TCP_COMMAND_HANDLER_H
#define TCP_COMMAND_HANDLER_H

// Project includes
#include "tcp_command_interface.hpp"

// Standard includes
#include <functional>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

/**
 * @class TCP_Commands
 * @brief Implements command routing and response generation.
 *
 * @details
 * This class registers command strings and associates them with handler
 * functions. Incoming commands are routed to their appropriate handlers,
 * optionally using arguments.
 */
class TCP_Commands : public TCP_CommandHandler
{
public:
    /**
     * @brief Constructs the TCP_Commands handler object.
     *
     * @details
     * Initializes the list of command-handler pairs and builds the
     * handler map.
     */
    TCP_Commands();

    /**
     * @brief Handles an incoming command from the TCP server.
     *
     * @param command The command name as a string.
     * @param arg Optional argument for the command.
     * @return A response string to be sent back to the client.
     */
    std::string handleCommand(const std::string &command,
                              [[maybe_unused]] const std::optional<std::string> &arg) override;

private:
    /**
     * @brief Ordered list of command-handler pairs.
     *
     * @details
     * This vector preserves the order in which commands are registered,
     * and pairs each command string with its corresponding lambda handler.
     */
    std::vector<std::pair<std::string,
                          std::function<std::string(const std::optional<std::string> &)>>>
        command_pairs;

    /**
     * @brief Internal mapping from command string to handler function.
     *
     * @details
     * Used for fast lookup and routing of incoming commands.
     */
    std::unordered_map<std::string,
                       std::function<std::string(const std::optional<std::string> &)>>
        command_handlers;

    /**
     * @brief Ordered list of valid command names.
     *
     * @details
     * Used to return user-friendly help messages or listings.
     */
    std::vector<std::string> valid_commands;

    /**
     * @brief Routes a command to the appropriate handler.
     *
     * @param command The command string.
     * @param arg The optional argument for the command.
     * @return The response generated by the handler.
     */
    std::string processCommand(const std::string &command,
                               const std::optional<std::string> &arg) override;

    /**
     * @name Command Handlers
     * @brief Handler functions for specific command types.
     *
     * @details
     * Each handler receives an optional argument and returns a response
     * string. These functions are registered in `initializeHandlers()`.
     */
    ///@{

    // [Control]
    std::string handleTransmit([[maybe_unused]] const std::optional<std::string> &arg);

    // [Common]
    std::string handleCall([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleGrid([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleDBM([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleFreq([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleTxPin([[maybe_unused]] const std::optional<std::string> &arg);

    // [Extended]
    std::string handlePPM([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleUseNTP([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleOffset([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleUseLED([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleLEDPin([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleXmitVal([[maybe_unused]] const std::optional<std::string> &arg);

    // [Server]
    std::string handleShutdown([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleShutdownPin([[maybe_unused]] const std::optional<std::string> &arg);

    // [Misc]
    std::string handleVersion([[maybe_unused]] const std::optional<std::string> &arg);
    std::string handleHelp([[maybe_unused]] const std::optional<std::string> &arg);
    ///@}
};

#endif // TCP_COMMAND_HANDLER_H
